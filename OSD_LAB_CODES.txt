cat.c:-(lab-1.1)
------
#include "types.h"
#include "stat.h"
#include "user.h"

char buf[512];

void
cat(int fd)
{
  int n;

  while((n = read(fd, buf, sizeof(buf))) > 0)
    write(1, buf, n);
  if(n < 0){
    printf(1, "cat: read error\n");
    exit();
  }
}

int
main(int argc, char *argv[])
{
  int fd, i;

  if(argc <= 1){
    cat(0);
    exit();
  }

  for(i = 1; i < argc; i++){
    if((fd = open(argv[i], 0)) < 0){
      printf(1, "cat: cannot open %s\n", argv[i]);
      exit();
    }
    cat(fd);
    close(fd);
  }
  exit();
}

fork.c:(lab-1-2.c)
-------
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>

int main (void)
{
  int pid;
  pid = fork();

if(pid > 0){

printf("parent: child=%d\n", pid);

pid = wait();

printf("child %d is done\n", pid);

} else if(pid == 0){

printf("child: exiting\n");

exit(0);

} else {

printf("fork error\n");

}
}
Write a program using C library functions for file handling Standard I/O library that will copy data from one file to another file:(post-lab-1)
-----------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h> // For exit()
  
int main()
{
    FILE *fptr1, *fptr2;
    char filename[100], c;
  
    printf("Enter the filename to open for reading \n");
    scanf("%s", filename);
  
    // Open one file for reading
    fptr1 = fopen(filename, "r");
    if (fptr1 == NULL)
    {
        printf("Cannot open file %s \n", filename);
        exit(0);
    }
  
    printf("Enter the filename to open for writing \n");
    scanf("%s", filename);
  
    // Open another file for writing
    fptr2 = fopen(filename, "w");
    if (fptr2 == NULL)
    {
        printf("Cannot open file %s \n", filename);
        exit(0);
    }
  
    // Read contents from file
    c = fgetc(fptr1);
    while (c != EOF)
    {
        fputc(c, fptr2);
        c = fgetc(fptr1);
    }
  
    printf("\nContents copied to %s", filename);
  
    fclose(fptr1);
    fclose(fptr2);
    return 0;
}
io.c(post-lab-1-2)
==================
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
int main(void)
{
	char buf[512];
	 int n;
 for(;;) {
 n = read(0, buf, sizeof buf);
 if(n == 0)
 break;
 if(n < 0) {
 fprintf(2, "read error\n");
 exit(0); }
 if(write(1, buf, n) != n) {
 fprintf(2, "write error\n");
 exit(0);
 }
 }
}
dup2.c(in-lab-2-2.c)
--------------------
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
int main(int argc, char* argv[])
{
	int source, des, rd, wr, flag;
	char data [100];
	source=open (argv [1], O_RDONLY) ;
	flag=dup2(source, des);
	
	rd=read(des, data, sizeof (data) );
	wr=write (1, data, rd) ;
	close(source) ;
	return 0;
}
cp.c(in-lab-2-1.c):
before typing filename1.txt filename2.txt
create file2
and type some data in it remove it and save it as empty file
------------------
#include "types.h"
#include "stat.h"
#include "fcntl.h"
#include "user.h"
int main(int argc,char *argv[])
{
  //Declaration of Variables
  int SourceFD,TargetFD,RdFlag,WrFlag;
  char Data[20];
 //Step1 Opening the Source File
  SourceFD=open(argv[1],O_RDONLY);
 //If unable to open source file error is displayed
  if(SourceFD<0)
  {
        printf(1, "Error in Opening the File");
	       exit();
  }
//Step2 Reading the Data from the Source File
RdFlag=read(SourceFD,Data,sizeof(Data)); 
//If unable to Read the Data from source file error //is displayed
if(RdFlag<0) 
{
     printf(1, "Error in Reading the File");
     exit();
}
//Step3 Opening the Target File
TargetFD=open(argv[2],O_CREATE|O_WRONLY);
//If unable to open Target file error is displayed
if(RdFlag<0) 
{
     printf(1, "Error in Reading the File");
     exit();
}
//Step4 Writing the Data into the Target File
  WrFlag=write(TargetFD,Data,sizeof(Data));
//If unable to Write the Data into Target file error is displayed
  if(WrFlag<0)
  {
        printf(1, "Error in Writing the Data into Target File");
        exit();
  }
 //Step5 Closing the Source and Target Files
  close(SourceFD);
  close(TargetFD);
  return 0;
}
============================================================================================
LAB3
zombie as lab3zombie.c:(execution finished after sleep after it removed)
-----------------------
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
int main()
{
    // Fork returns process id
    // in parent process
    pid_t child_pid = fork();
  
    // Parent process 
    if (child_pid > 0)
        sleep(5);
  
    // Child process
    else        
        exit(0);
  
    return 0;
}
===============================================================================
orphan as lab3_orphan.c:(Parent process executed and leaves with out waiting for child process terminiation after some time child process terminates)
-------------------------
#include<stdio.h>
#include <sys/types.h>
#include <unistd.h>
  
int main()
{
    // Create a child process      
    int pid = fork();
  
    if (pid > 0)
        printf("in parent process");
  
    // Note that pid is 0 in child process
    // and negative if fork() fails
    else if (pid == 0)
    {
        sleep(3);
        printf("in child process");
    }
  
    return 0;
}
=====================================================================================================
pipe.c as lab4pipe.c:
---------------------
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
void quit (char *message, int exit_status)
{
  printf(" %s",message);
  exit(exit_status);
}
int main()
{
  int fd[2]; /* To be filled up by pipe() */
  if (pipe(fd < 0)) /* Now have four descriptors for pipe */
  printf("os lead");
  switch (fork())
  {
    case -1: quit("fork", 2);
    case 0: close(fd[0]); /* CHILD - Close read end first*/
            dup2(fd[1], STDOUT_FILENO); /*Connect stdout to  write end */
            close(fd[1]); /* and close original descriptor */
            execlp("cat", "cat", "1.txt", (char *) 0);
            quit("cat", 3);
    default:close(fd[1]); /*PARENT - Close write end first */
            dup2(fd[0], STDIN_FILENO); /*Connect stdin to read end*/
            close(fd[0]); /* and close original descriptor */
            execlp("tr", "tr", "[a-z]","[A-Z]", (char *) 0);
            quit("tr", 4);
  }
}
unlink.c as lab4_unlink.c:
-----------------------------
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
int main(argc, argv)
int argc;
char *argv[];
{
int fd;
char buf[10241];
struct stat statbuf;
if(argc !=2) /* need a parameter */
exit(1);
fd = open(argv[1], O_RDONLY);
if(fd ==-1) /* open fails */
exit(1);
if(unlink(argv[1])==-1) /* unlink file just opened */
exit(1);
if(stat(argv[1], &statbuf)==-1) /* stat the file by name*/
printf("stat %s fails as it should\n", argv[1]);
else
printf("stat %s succeeded!!!!\n", argv[1]);
if(fstat(fd, &statbuf)==-1)
{ /* stat the file by fd */
printf("fstat %s fails!!!\n", argv[1]);
}
else
{
printf("fstat %s succeeds as it should\n", argv[1]);
}
while(read(fd,buf,sizeof(buf)>0))    /* read open/unlinked file */
{
printf("%1024s", buf); /* prints 1K byte field */
}
}
==========================================
link.c(available in lab4 programs.docx in lms practical 4 question 3)
------

LAB-05:
------
attribute.c as lab5_attribute.c:-(./a.out filename)
---------------------------------
#include <stdio.h>
#include <sys/stat.h>   /* For struct stat */
#include <stdarg.h>
#include <stdlib.h>
#include <time.h>
void quit(char *message, int exit_status)
{
        printf(" %s",message);
        exit(exit_status);
}
void arg_check (long int args, long int argc, char *message, long int exit_status)
{
if (argc != args)
{
printf("%s", message);
exit(exit_status);
}
}
int main(long int argc, char **argv)
{
struct stat statbuf;  /* We’ll use lstat to populate this */
arg_check(2, argc, "Single filename required\n", 1) ;
if(lstat(argv[1], &statbuf) == -1)
quit("Couldn’t stat file", 1);
printf("File: %s\n", argv[1]);
printf("Inode number: %ld \n", statbuf.st_ino);
printf("UID: %ld   ", statbuf.st_uid);
printf("GID: %ld\n", statbuf.st_gid);
printf("Type and Permissions: %o\n",statbuf.st_mode);
printf("Number of links: %ld \n", statbuf.st_nlink);
printf("Size in bytes: %ld\n", statbuf.st_size);
printf("Blocks allocated: %ld\n", statbuf.st_blocks);
printf("Last Modification Time: %s", ctime(&statbuf.st_mtime));
printf("Last Access Time: %s\n", ctime(&statbuf.st_atime));
exit(0);
}

lsdir.c as lab5_lsdir.c(create a directory using mkdir command and type ./a.out directory_name)
================================================================================================
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <dirent.h>
#include <stdlib.h>
#include <unistd.h>
void quit (char *message, int exit_status)
{
        printf(" %s",message);
        exit(exit_status);
}
void arg_check(int args, int argc, char *message, int exit_status)
{
if(argc != args)
{
printf("%s", message);
exit(exit_status);
}
}
int main(int argc, char *argv[])
{
DIR *dir;
struct dirent *direntry; /* Returned by readdir() */
struct stat statbuf; /* Address of statbuf used by lstat() */
mode_t file_type,file_perm;
arg_check(2, argc, "Directory not specified\n", 1) ;
if((dir = opendir(argv[1])) == NULL)
quit("Couldn’t open directory", 1);
if((chdir(argv[1]) == -1)) /* Change to the directory before */
quit("chdir", 2); /* you starting reading its entries */
while((direntry = readdir(dir)) != NULL)
{
/* Read each entry in directory*/
if(lstat(direntry->d_name, &statbuf) < 0)
{
/* dname must be in */
perror("lstat");
/* current directory */
continue;
}
if(S_ISDIR(statbuf.st_mode))
{
/* If file is a directory */
file_type = statbuf.st_mode & S_IFMT;
file_perm = statbuf.st_mode & ~S_IFMT;
printf("%o %4o %s\n",file_type,file_perm,direntry->d_name);
}
}
exit(0);
}

===========================
chown(present in lab5 program.docx in OSD practical 5 question 3)
======
chmod(present in lab5 program.docx in OSD practical 5 question 4 )

=================================================================================================================================================
LAB-06
------
siginal.c
--------
#include <stdio.h>
#include <sys/stat.h>   /* For struct stat */
#include <stdarg.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
 #include <signal.h> 
#define BUFSIZE 100
void alrm_handler(int signo); /* Prototype declaration */
char buf[BUFSIZE] = "foo\0"; /* Global variable */
void quit(char *message, int exit_status)
{
        printf(" %s",message);
        exit(exit_status);
}

int main (void) {
int n; 
struct sigaction act;
 act.sa_handler = alrm_handler; /* Specify handler */ 
if (sigaction(SIGALRM, &act, NULL) == -1) /* Install handler */ 
	quit("sigalrm", 1); 
	fprintf(stderr, "Enter filename: "); 
	alarm(5); /* Set alarm clock; will deliver */ 
	n = read(STDIN_FILENO, buf, BUFSIZE); /* SIGALRM in 5 seconds */ 
	if (n > 1) /* Will come here if user inputs */ 
	fprintf(stderr, "Filename: %s\n", buf); /* string within 5 seconds */ 
	exit(0); 
}
void alrm_handler(int signo) 
{ 
	fprintf(stderr, "\nSignal %d received, default filename: %s\n", signo, buf); 
	exit(1);
}

kill.c
======
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <stdlib.h>

pid_t pid;
int main (int argc, char **argv) {
 int i, status;
 void death_handler(int signo); /* A common signal handler this time */

 struct sigaction act;
 act.sa_handler = death_handler;
 sigaction(SIGCHLD, &act, NULL); /* Disposition for these two signals */
 sigaction(SIGALRM, &act, NULL); /* set to enter a single handler */

 switch (pid = fork()) {
 case -1: fprintf(stderr, "Fork error\n");
 case 0: execvp(argv[1], &argv[1]); /* Execute command */
 perror("exec");
 break;
 default: alarm(5); /* Will send SIGALRM after 5 seconds */
 pause(); /* Will return when SIGCHLD signal is received */
 fprintf(stderr, "Parent dies\n");
 }
 exit(0);
}
void death_handler(int signo) { /* This common handler picks up the */
 int status; /* exit status for normal termination */
 /* but sends the SIGTERM signal if */
 switch (signo) { /* command doesn’t complete in 5 seconds */
 case SIGCHLD: waitpid(-1, &status, 0); /* Same as wait(&status); */
 fprintf(stderr, "Child dies; exit status: %d\n",WEXITSTATUS(status));
 break;
 case SIGALRM: if (kill(pid, SIGTERM) == 0)
 fprintf(stderr, "5 seconds over, child killed\n");
 }
}


nice.c:
----------

#include <stdio.h>
main ()
{
 printf ("original priority\n");
 system ("ps -l"); /* Execute a ps */
 nice (0); /* Add 0 to my priority */
 printf ("running at priority 0\n");
 system ("ps -l"); /* Execute another ps */
 nice (10); /* Add 10 to my priority */
 printf ("running at priority 10\n");
 system ("ps -l"); /* Execute the last ps */
}

times.c:
-----------


#include <stdio.h>
#include <unistd.h>
#include <sys/times.h>
#include <time.h>

int main() {
    struct tms times_start, times_end;
    clock_t times_start_retval, times_end_retval;
    clock_t clock_start, clock_end;

    int i;
    /* clock called first and last, so estimates using "clock" should be
       slightly longer than estimates using "times" */
    if((clock_start = clock()) == -1) {
        perror("starting clock");
        return -1;
    }

    if((times_start_retval = times(&times_start)) == -1) {
        perror("starting times");
        return -1;
    }

    for(i = 100000000; i; i--); // do work

    if((times_end_retval = times(&times_end)) == -1) {
        perror("ending timer");
        return -1;
    }
    printf("Times using the clock system call\n");
    printf("clock start: %li\nclock end: %li\n", clock_start, clock_end);
    printf("elapsed: %li\n\n", clock_end - clock_start);

    printf("Times using the times system call\n");
    printf("System start: %li\nUser start: %li, start retval: %li\n",
        times_start.tms_stime, times_start.tms_utime, times_start_retval);
    printf("System end:   %li\nUser end:   %li, end retval:   %li\n",
        times_end.tms_stime, times_end.tms_utime, times_end_retval);
    printf("elapsed: %li\n\n", times_end_retval - times_start_retval);

    return 0;
}

time.c
---------

/* time example */
#include <stdio.h>      /* printf */
#include <time.h>       /* time_t, struct tm, difftime, time, mktime */

int main ()
{
  time_t timer;
  struct tm y2k = {0};
  double seconds;

  y2k.tm_hour = 0;   y2k.tm_min = 0; y2k.tm_sec = 0;
  y2k.tm_year = 100; y2k.tm_mon = 0; y2k.tm_mday = 1;

  time(&timer);  /* get current time; same as: timer = time(NULL)  */

  seconds = difftime(timer,mktime(&y2k));

  printf ("%.f seconds since January 1, 2000 in the current timezone", seconds);

  return 0;
}
===========================================================================================================================================
LAB-07:
=======
1. Write a program to display the address space of various segments (stack, heap, data ...etc) and show that memory address a programmer see is virtual not real. 
code:
-----
#include<stdio.h>
#include<malloc.h>
int glb_uninit;  /* Part of BSS Segment -- global uninitialized variable, at 
                  runtime it is initialized to zero */
int glb_init = 10; /* Part of DATA Segment -- global initialized variable */
void foo(void)
{
static int num = 0; /* stack frame count */
int autovar;	/* automatic variable/Local variable */
int *ptr_foo = (int*)malloc(sizeof(int)); /* allocate memory using malloc*/

if (++num == 4) /* Creating four stack frames */
return;
printf("Stack frame number %d: address of autovar: %p\n", num, & autovar);
printf("Address of heap allocated inside foo() %p\n",ptr_foo);
foo();/* function call */
}
int main()
{
char *p, *b, *nb;
int *ptr_main = (int*)malloc(sizeof(int)); /* allocate memory using malloc*/
printf("Text Segment:\n");
printf("Address of main: %p\n", main);
printf("Address of afunc: %p\n",foo);
printf("Stack Locations:\n");
foo();
printf("Data Segment:\n");
printf("Address of glb_init: %p\n", & glb_init);
printf("BSS Segment:\n");
printf("Address of glb_uninit: %p\n", & glb_uninit);
printf("Heap Segment:\n");
printf("Address of heap allocated inside main() %p\n",ptr_main);
return 0;
}

2. Develop a program to illustrate the effect of free() on the program break. This program allocates multiple blocks of memory and then frees some or all of them, depending on its (optional) command-line arguments.

#define MAX_ALLOCS 1000000
#include <stdio.h> /* Standard I/O functions */
#include <stdlib.h> /* Prototypes of commonly used library functions,plus EXIT_SUCCESS and EXIT_FAILURE constants */
#include <unistd.h> /* Prototypes for many system calls */
#include <errno.h> /* Declares errno and defines error constants */
#include <string.h> /* Commonly used string-handling functions */
int main(int argc, char *argv[])
{
char *ptr[MAX_ALLOCS];
int freeStep, freeMin, freeMax, blockSize, numAllocs,j;
printf("\n");
if (argc < 3 || strcmp(argv[1], "--help") == 0)
{
printf("%s num-allocs block-size [step [min [max]]]\n", argv[0]);
exit(5); 
}
numAllocs = strtol(argv[1], NULL, 10);
if (numAllocs > MAX_ALLOCS)
{ 
printf("num-allocs > %d\n", MAX_ALLOCS);
exit(5); 
}
blockSize = strtol(argv[2], NULL, 10);
freeStep = (argc > 3) ? strtol(argv[3], NULL, 10): 1;
freeMin = (argc > 4) ? strtol(argv[4], NULL, 10) : 1;
freeMax = (argc > 5) ? strtol(argv[5], NULL, 10) : numAllocs;
if (freeMax > numAllocs)
{ 
printf("free-max > num-allocs\n");
exit(5); 
}
printf("Initial program break: %10p\n", sbrk(0));
printf("Allocating %d*%d bytes\n", numAllocs, blockSize);
for (j = 0; j < numAllocs; j++) 
{
ptr[j] = malloc(blockSize);
if (ptr[j] == NULL)
{ 
perror("malloc");
exit(5); 
}
}
printf("Program break is now: %10p\n", sbrk(0));
printf("Freeing blocks from %d to %d in steps of %d\n",freeMin, freeMax, freeStep);
for (j = freeMin -1; 
j < freeMax; 
j += freeStep)free(ptr[j]);
printf("After free(), program break is: %10p\n", sbrk(0));
exit(10);
}

POST_LAB
-------
1. Write a simple memory allocator: memalloc is a simple memory allocator. Which uses your own malloc(), calloc(), realloc() and free() implemented using system calls.
#include <sys/types.h> /* Type definitions used by many programs */
#include <stdio.h> /* Standard I/O functions */
#include <stdlib.h> /* Prototypes of commonly used library functions,plus EXIT_SUCCESS and EXIT_FAILURE constants */
#include <unistd.h> /* Prototypes for many system calls */
#include <errno.h> /* Declares errno and defines error constants */
#include <string.h> /* Commonly used string-handling functions */
extern char end;
void *my_malloc (size_t);
void my_free(void *);
struct blk {size_t size;
struct blk *prev;
struct blk *next;};
struct blk *first = NULL;
struct blk *last = NULL;
void *my_malloc (size_t size) {size_t required_size = size + sizeof(struct blk);
struct blk *curr = first;
while (curr != NULL && curr->size < required_size) 
{
curr = curr->next;
}
if (curr == NULL) {void *new = sbrk((intptr_t) required_size);
if (new == (void *) -1) { return NULL; }
struct blk *new_blk = (struct blk *) new;
new_blk->size = required_size;
return (void *) (new_blk + 1);}
if (curr == first) { first = first->next; }
else { curr->prev->next = curr->next; }
if (curr == last) { last = last->prev; }
else {curr->next->prev = curr->prev; 
}if (curr->size > required_size + sizeof(struct blk)) {struct blk *left = (struct blk *) (((char *) curr) + required_size);
left->size = curr->size -required_size;
curr->size = required_size;
my_free((char *) (left + 1));}
return (void *) (curr + 1);}
void my_free (void *ptr) {struct blk *blk_ptr = ((struct blk *) ptr) -1;
if (first == NULL) {first = last = blk_ptr;return;}
if (blk_ptr < first) {blk_ptr->prev = NULL;
if (((char *) blk_ptr) + blk_ptr->size == (char *) first) {blk_ptr->size += first->size;
blk_ptr->next = first->next;}
 else {first->prev = blk_ptr;blk_ptr->next = first;}first = blk_ptr;return;}
if (blk_ptr > last) {if (((char *) last) + last->size == (char *) blk_ptr) {last->size += blk_ptr->size;} 
else {blk_ptr->next = NULL;
blk_ptr->prev = last;
last->next = blk_ptr;
last = blk_ptr;}
return;}
struct blk *curr = first;
while (curr < blk_ptr) {curr = curr->next;}
struct blk *before = curr->prev;
if (((char *) before) + before->size == (char *) blk_ptr) {before->size += blk_ptr->size;
blk_ptr = before;}
 else {blk_ptr->prev = before;
before->next = blk_ptr;}
if (((char *) blk_ptr) + blk_ptr->size == (char *) curr) {blk_ptr->size += curr->size;
blk_ptr->next = curr->next;
curr->next->prev = blk_ptr;
}
else {blk_ptr->next = curr;
curr->prev = blk_ptr;}}
#define MAX_ALLOCS 1000000
int main (int argc, char *argv[]) {
/* copied from free_and_sbrk.c --licensed by Michael Kerrisk under the GPLv3 */
char *ptr[MAX_ALLOCS];
int freeStep, freeMin, freeMax, blockSize, numAllocs, j;
printf("\n");
if (argc < 3 || strcmp(argv[1], "--help") == 0) {printf("%s num-allocs block-size [step [min [max]]]\n", argv[0]);
perror("num-allocs block-size");}
numAllocs = strtol(argv[1], NULL, 10);
if (numAllocs > MAX_ALLOCS) {printf("num-allocs > %d\n", MAX_ALLOCS);
perror("num-allocs");}
blockSize = strtol(argv[2], NULL, 10);
freeStep = (argc > 3) ? strtol(argv[3], NULL, 10) : 1;
freeMin = (argc > 4) ? strtol(argv[4], NULL, 10) : 1;
freeMax = (argc > 5) ? strtol(argv[5], NULL, 10): numAllocs;
if (freeMax > numAllocs) {perror("free-max > num-allocs");}
printf("Initial program break: %10p\n", sbrk(0));
printf("Allocating %d*%d bytes\n", numAllocs, blockSize);
for (j = 0; j < numAllocs; j++) {
ptr[j] = my_malloc(blockSize);
if (ptr[j] == NULL) {perror("malloc");}
printf("%10p\n", sbrk(0));}
printf("Program break is now: %10p\n", sbrk(0));
printf("Freeing blocks from %d to %d in steps of %d\n",freeMin, freeMax, freeStep);
for (j = freeMin -1; j < freeMax; j += freeStep) {my_free(ptr[j]);}
printf("After my_free(), program break is: %10p\n", sbrk(0));
exit(EXIT_SUCCESS);}

osdlab:~/programs$ ./a.out 1000 10240 1 1 999


================================================================================================================================================
lab-08
------
VM.c
----
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#define PSIZE 4096
int main(int argc, char *argv[])
{
	int addressFile,backingStore; 				
	char *file= argv[1];	
	char ch,ct, input[1000], output;
	int logicalAddress, physicalAddress;	
	int i=0, j=0;
	int p,d;											
	int f; 										
	char frames[PSIZE*16]; 					
	int frametable[16];						
	int start, current;							
	int offset, pagefault=0;	
	int freeFrame=-1;	
	int pagetable[16]; 							
	for (j=0;j<16;j++)						
	{
		pagetable[j] = -1;
	}	
        pagetable[0]=0x2;
        pagetable[1]=0x1;
        pagetable[2]=0x6;
        pagetable[3]=0x0;
        pagetable[4]=0x4;
        pagetable[5]=0x3;
        pagetable[9]=0x5;
        pagetable[11]=0x7;
	for (j=0;j<16;j++)						
	{
		frametable[j] = -1;
	}	
	frametable[0] = 1;
	frametable[1] = 1;
	frametable[2] = 1;
	frametable[3] = 1;
	frametable[4] = 1;
	frametable[5] = 1;
	frametable[9] = 1;
	frametable[11] = 1;
	addressFile = open("address.txt",O_RDONLY); 
	backingStore = open("BACKING_STORE.bin",O_RDONLY); 
	if(addressFile != -1)
	{
		while(read(addressFile, &ch, sizeof(char)) != 0)	
		{
			if(ch != '\n')
			{
				input[i] = ch;
				i++;
			}
			else
			{
				logicalAddress =atoi(input);
				p = (logicalAddress & 0x000000000000f000UL) >>  12;
				d = (logicalAddress & 0x0000000000000fffUL);

				printf("\nlogicalAddress: %d, p: %d, d: %d", logicalAddress,p,d);

				if(pagetable[p]!= -1){

					f = pagetable[p];
					physicalAddress = (f * PSIZE) + d;
					printf("\nphysicalAddress: %d, f: %d", physicalAddress,f);

				}
//				pagetable-miss, page-fault	
				else
				{
					pagefault++;
//					locate free frame (-1) in physical memory 
					for (j=0;j<8;j++)
					{
						if(frametable[j]==-1)
						{
							freeFrame = j;
							break;	
						}
					}	 					
					if(backingStore != -1)
					{						
						
						offset=0;
						start = PSIZE * p;
						current=lseek(backingStore, start, SEEK_SET);
						while((offset < PSIZE)&&(current))
						{
							current = read(backingStore, &ct, sizeof(char));
							frames[freeFrame*offset] = ct; 
							offset++;														
						}
					}
					else
					{
						printf("Backing-Store Does not exist!");
						close(backingStore);
						close(addressFile);	
						return 0;	
					}
//					update pagetable, frametable
					pagetable[p] = freeFrame;	
					frametable[freeFrame] = 0;

					physicalAddress = (freeFrame * PSIZE) + d;
					printf("\nphysicalAddress: %d, freeFrame: %d", physicalAddress, freeFrame);
				}

				output = frames[physicalAddress];
				printf("\nByte value stored at physicalAddress %d: %c\n",physicalAddress, output);
				
				memset(input,0,sizeof(input));
				i=0;

			}
		}
		printf("\nTotal Page Faults: %d",pagefault);		
	}
	else
		printf("Addresses File Does not exist!");

	close(backingStore);
	close(addressFile);	
	return 0;	
}



pagetable.c
----------
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

struct page{
	int page_no;
	int frame;
};
int main()
{
	int size_logical_address,size_physical_address,i,size_of_page,j;
	printf("Enter size of logical address space: ");
	scanf("%d",&size_logical_address);
	printf("Enter size of physical address space: ");
	scanf("%d",&size_physical_address);
	printf("Enter size of page: ");
	scanf("%d",&size_of_page);

	int number_of_frames = size_physical_address/size_of_page;
	int number_of_pages = size_logical_address/size_of_page;

	struct page pageTable[number_of_pages];
	printf("Enter page table: \n");
	for(i=0;i<number_of_pages;i++)
	{
		pageTable[i].frame = -1;
	}
	for(i=0;i<number_of_pages;i++)
	{
		int frame;
		bool replica = false;
		pageTable[i].page_no = i;
		printf("Enter frame for %d page number(-1 if frame doesn't exist): ",i);
		scanf("%d",&frame);
		for(j=0;j<number_of_pages;j++)
		{
			if(frame!= -1 && pageTable[j].frame == frame)
			{
				replica = true;
				printf("Frame number already stored\n");
			}
		}
		if(frame > number_of_frames)
		{
			replica = true;
			printf("Cannot exceed frame size\n");
		}
		if(replica == false)
		{
			pageTable[i].frame = frame;
		}
	}
	int logical_address;
	printf("Enter -1 to exit\n");
	while(1)
	{
		printf("Enter logical address: ");
		scanf("%d",&logical_address);
		if(logical_address == -1)
			return 0;

		int page_no = logical_address/size_of_page;
		int offset = logical_address%size_of_page;
		if(pageTable[page_no].frame == -1)
		{
			printf("No such logical address exist\n");
		}
		else
		{
			printf("Page no: %d \nOffset: %d\nFrame no: %d\nPhysical address: %d\n",page_no, offset, pageTable[page_no].frame,pageTable[page_no].frame*size_of_page + offset );
		}
	}
}

address.txt
----------
16916
62493
30198
53683

backstore code a file provided

execution:
---------
gcc vm.c
./a.out
=================================================================================================================================================
LAB-09
------
fifo.c :
---------------

/*
	FIFO Page Replacement Algorithm
*/
#include "stdio.h"
#include "stdlib.h"
#include "stdbool.h"

int pointer;
int faults ,hits;
void print(int frame_size,int frame[])
{
	int i;
	//printf("Printing the Frames: ");
	for(i=0;i<frame_size;i++)
	{
		if(frame[i]==-1)
			printf("- ");
		else
			printf("%d ",frame[i]);
	}

	printf("\n");
}

void add_reference(int frame_size,int frame[], int reference)
{
	int i;
	bool alloted = false;
	for(i=0;i<frame_size;i++)
	{
		if(frame[i]==reference)
		{
			alloted = true;
			printf("  Hit for %d | ", reference);
			hits++;
			break;
		}
		else if(frame[i]==-1)
		{
			alloted = true;
			frame[i] = reference;
			printf("Fault for %d | ", reference);
			faults++;
			break;
		}
	}
	if(alloted == false)
	{
		faults++;
		printf("Fault for %d | ", reference);
		frame[pointer] = reference;
		pointer = (pointer+1)%frame_size;
	}
	print(frame_size, frame);
}

int main()
{
	int frame_size,i,number_of_references;
	printf("Enter frame size: ");
	scanf("%d",&frame_size);
	int frame[frame_size];
	for(i=0;i<frame_size;i++)
	{
		frame[i] = -1;
	}

	print(frame_size,frame);
	
	printf("Enter the number of references: ");
	scanf("%d",&number_of_references);
	int reference[number_of_references];
	
	for(i=0;i<number_of_references;i++)
	{
		scanf("%d",&reference[i]);
		add_reference(frame_size,frame,reference[i]);
	}
	printf("\nNumber of faults: %d \nNumber of hits: %d\n",faults,hits );
}


lru.c
----------------
/*
	Least Recently Used Page Replacement Algorithm
*/
#include "stdio.h"
#include "stdlib.h"
#include "stdbool.h"

int pointer;
int faults ,hits;
void print(int frame_size,int frame[])
{
	int i;
	//printf("Printing the Frames: ");
	for(i=0;i<frame_size;i++)
	{
		if(frame[i]==-1)
			printf("- ");
		else
			printf("%d ",frame[i]);
	}

	printf("\n");
}

int predict(int reference_length, int references[], int page_no ,int frame_size,int frame[], int start)
{
	int pos = -1, farthest = start, i;
	for(i=0;i<frame_size;i++)
	{
		int j;
		for(j=start-1;j>=0;j--)
		{
			if(frame[i]==references[j])
			{
				if(j<farthest)
				{
					farthest=j;
					pos=i;
				}
				break;
			}
		}
		if(j==page_no)
			return i;
	}
	if(pos == -1)
		return 0;
	else
		return pos;
}

void add_reference(int frame_size,int frame[], int reference, int current_position,int reference_length, int references[])
{
	int i;
	bool allocated=false;
	for(i=0;i<frame_size;i++)
	{
		
		if(frame[i]==reference)
		{
			printf("  Hit for %d | ", reference);
			hits++;
			allocated = true;
			break;
		}
		else if(frame[i]==-1)
		{
			frame[i] = reference;
			printf("Fault for %d | ", reference);
			faults++;
			allocated = true;
			break;
		}
	}
	if(allocated==false)
	{
		int j = predict(reference_length,references,current_position,frame_size,frame,current_position+1);

		frame[j] = reference;
		printf("Fault for %d | ", reference);
		faults++;	
	}
	print(frame_size, frame);
}

int main()
{
	int frame_size,i,number_of_references;
	printf("Enter frame size: ");
	scanf("%d",&frame_size);
	int frame[frame_size];
	for(i=0;i<frame_size;i++)
	{
		frame[i] = -1;
	}

	print(frame_size,frame);
	
	printf("Enter the number of references: ");
	scanf("%d",&number_of_references);
	int reference[number_of_references];
	
	for(i=0;i<number_of_references;i++)
	{
		scanf("%d",&reference[i]);
		add_reference(frame_size,frame,reference[i],i,number_of_references,reference);
	}
	printf("\nNumber of faults: %d \nNumber of hits: %d\n",faults,hits );
}

================================================================================================================================================
lab-10
------
simplethread.c
--------------
#include <stdio.h>
#include <pthread.h>
void* worker( void* p ) {
    int* ip = (int*)p;
    printf("Hello world from thread ID:%d,thread number %i!\n",pthread_self(),*ip);
}
int main() {
     pthread_t OtherThread[4];
     int i;
     for(i=0;i<4;i++) {
        pthread_create( &OtherThread[i], NULL, worker, &i );
        sleep(1);
    }
}

shm.c
-----
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#define  SHM_SIZE   1024 /* make it a 1K shared memory segment */
int main(int argc, char *argv[])
{
    key_t   key;
    int   shmid;
    char   *data;
    int    mode;
    if (argc > 2) {
          fprintf(stderr,"usage: shmdemo [data_to_write]\n");
         exit(1);
  }
  /* make the key: */
if ((key = ftok("shm.c", 'R')) == -1)
{ 
     perror("ftok");
     exit(1);
}
/* connect to (and possibly create) the segment: */
if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1)
{ 
    perror("shmget");
    exit(1);
}
/* attach to the segment to get a pointer to it:*/
data = shmat(shmid, (void *)0, 0);
if (data == (char *)(-1))
{    perror("shmat");
    exit(1);
}
/* read or modify the segment, based on the command line: */
if (argc == 2)
 {
    printf("writing to segment: \"%s\"\n", argv[1]);
    strncpy(data, argv[1], SHM_SIZE);
} else
{
    printf("segment contains: \"%s\"\n", data);
/* detach from the segment: */
    shmctl(shmid, IPC_RMID, NULL);
}
if (shmdt(data) == -1) {
     perror("shmdt");
     exit(1);
}
}

=================================================================================================================================================
lab-11
------
pre-lab
=======
1)Creating and Destroying Mutexes: pthread_mutex_init (mutex,attr) pthread_mutex_destroy
mutex.c
-------
#include
<stdio.h>
#include <pthread.h>
int done = 0;
void* worker(void* arg) {
printf("this should print first\n");
done = 1;
return NULL;}
int main(int argc, char *argv[]) {
pthread_t p;
pthread_create(&p, NULL, worker, NULL);
while (done == 0)
printf("this should print last\n");
return 0;
}

steps:
-----
gcc file_name.c -pthread
./a.out
ii) Locking and Unlocking Mutexes: pthread_mutex_lock (mutex) pthread_mutex_trylock ?
lock-mutex.c
-------------
#include <stdio.h>
#include <pthread.h>
typedef struct synchronizer_t {
pthread_mutex_t lock;
pthread_cond_t cond;
int done;
} synchronizer_t;
synchronizer_t s;
void signal_init(synchronizer_t *s) {
pthread_mutex_init(&s->lock,
NULL); pthread_cond_init(&s->cond,
NULL); s->done = 0;
}
void signal_done(synchronizer_t *s)
{ pthread_mutex_lock(&s->lock);
s->done = 1;
pthread_cond_signal(&s->cond);
pthread_mutex_unlock(&s->lock)
;
}
void signal_wait(synchronizer_t *s)
{ pthread_mutex_lock(&s->lock);
while (s->done == 0)
pthread_cond_wait(&s->cond,
&s->lock); pthread_mutex_unlock(&s->lock);
}
void* worker(void* arg) {
printf("this should print first\n");
signal_done(&s);
return NULL;
}
int main(int argc, char *argv[]) {
pthread_t p;
signal_init(&s);
pthread_create(&p, NULL, worker, NULL);
signal_wait(&s);
printf("this should print last\n");
return 0;
}

steps:
------
gcc filename.c -pthread
./a.out

IN_lab
------
1) Illustrate how mutex is used for thread synchronization, print the counter variable
upon each increment which is in the critical section. (Two threads update a global shared
variable with and without synchronization)?
thread_incr_mutex.c
-------------------
#include <pthread.h>
static volatile int glob = 0;   /* "volatile" prevents compiler optimizations
                                   of arithmetic operations on 'glob' */
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
static void *                   /* Loop 'arg' times incrementing 'glob' */
threadFunc(void *arg)
{
    int loops = *((int *) arg);
    int loc, j;

    for (j = 0; j < loops; j++) {
        pthread_mutex_lock(&mtx);
	loc = glob;
        loc++;
        glob = loc;
	pthread_mutex_unlock(&mtx);
    }
    return NULL;
}
int
main(int argc, char *argv[])
{
    pthread_t t1, t2;
    int loops, s;
    loops = strtol(argv[1], NULL, 10);
    s = pthread_create(&t1, NULL, threadFunc, &loops);
    if (s != 0){
        perror("pthread_create fail");
	exit(1);}
    s = pthread_create(&t2, NULL, threadFunc, &loops);
    if (s != 0){
        perror("pthread_create fail");
	exit(2);}

    s = pthread_join(t1, NULL);
    if (s != 0){
        perror("pthread_join fail");
	exit(1);}
    s = pthread_join(t2, NULL);
    if (s != 0){
        perror("pthread_join fail");
	exit(1);}

    printf("glob = %d\n", glob);
    exit(0);
}
steps:
------
/*
[vishnu@team-osd ~]$ vi thread_incr_mutex.c
[vishnu@team-osd ~]$ cc thread_incr_mutex.c -lpthread
[vishnu@team-osd ~]$ ./a.out 500
glob = 1000
[vishnu@team-osd ~]$ ./a.out 50000
glob = 100000
[vishnu@team-osd ~]$ ./a.out 5000000
glob = 10000000
*/

2.1)thread_incr without mutex(lab11-thread-incr.c):
-----------------------------------------------------
 *             */
#include <pthread.h>

static volatile int glob = 0;   /* "volatile" prevents compiler optimizations
                                   of arithmetic operations on 'glob' */
static void *                   /* Loop 'arg' times incrementing 'glob' */
threadFunc(void *arg)
{
    int loops = *((int *) arg);
    int loc, j;

    for (j = 0; j < loops; j++) {
        loc = glob;
        loc++;
        glob = loc;
    }
    return NULL;
}
int
main(int argc, char *argv[])
{
    pthread_t t1, t2;
    int loops, s;
    loops = strtol(argv[1], NULL, 10);
    s = pthread_create(&t1, NULL, threadFunc, &loops);
    if (s != 0){
        perror("pthread_create fail");
	exit(1);}
    s = pthread_create(&t2, NULL, threadFunc, &loops);
    if (s != 0){
        perror("pthread_create fail");
	exit(2);}

    s = pthread_join(t1, NULL);
    if (s != 0){
        perror("pthread_join fail");
	exit(1);}
    s = pthread_join(t2, NULL);
    if (s != 0){
        perror("pthread_join fail");
	exit(1);}

    printf("glob = %d\n", glob);
    exit(0);
}

steps:
------
/*
[vishnu@team-osd ~]$ vi thread_incr.c
[vishnu@team-osd ~]$ cc thread_incr.c -lpthread
[vishnu@team-osd ~]$ ./a.out 500
glob = 1000
[vishnu@team-osd ~]$ ./a.out 50000
glob = 100000
[vishnu@team-osd ~]$ ./a.out 5000000
glob = 6713290
*/


2) Write a UNIX system program to implement concurrent Linked List?
A) Code:-
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
typedef struct node_t {
int key;
struct node_t *next;
}
node_t;
typedef struct list_t {
node_t *head;
pthread_mutex_t lock;
}
list_t;
void List_Init(list_t *L)
{ L->head = NULL;
pthread_mutex_init(&L->lock, NULL);
}
void List_Insert(list_t *L, int key) {
node_t *new = malloc(sizeof(node_t));
if (new == NULL) {
perror("malloc");
return;
}
new->key = key;
pthread_mutex_lock(&L->lock)
; new->next = L->head;
L->head = new;
pthread_mutex_unlock(&L->lock)
;
}
int List_Lookup(list_t *L, int key)
{ int rv = -1;
pthread_mutex_lock(&L->lock);
node_t *curr = L->head;
while (curr) {
if (curr->key == key) {
rv = 0;
break;
}
curr = curr->next;
}
pthread_mutex_unlock(&L->lock);
return rv;
}
void List_Print(list_t *L)
{ node_t *tmp =
L->head; while (tmp) {
printf("%d ",
tmp->key); tmp =
tmp->next;
}
printf("\n");
}
int main(int argc, char *argv[])
{
list_t mylist;
List_Init(&mylist);
List_Insert(&mylist, 10);
List_Insert(&mylist, 30);
List_Insert(&mylist, 5);
List_Print(&mylist);
printf("In List: 10? %d 20? %d\n",
List_Lookup(&mylist, 10), List_Lookup(&mylist, 20));
return 0;
}

steps;
-----
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ nano cll.c
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ gcc cll.c -lpthread
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ ./a.out; ./a.out

post-lab
-----------
seamphore1.c
------------
code:
----
#include
<stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
sem_t done;
void *
child(void *arg) {
sleep(5);
printf("child\n");
sem_post(&done);
return NULL;}
int main(int argc, char *argv[]) {
pthread_t p;
printf("parent: begin\n");
sem_init(&done,0, 0);
pthread_create(&p, NULL, child, NULL);
sem_wait(&done);
printf("parent: end\n");
return 0;
}

steps:
------
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ gcc seamaphore1.c -lpthread
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ ./a.out

=================================================================================================================================================
lab-12
------
lab12-procedure-consuming-using-seamphore.c
------------------------------------------
code:
=====
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/types.h>
#define NBUFF 10
#define SEM_MUTEX "mutex" /* these are args to px_ipc_name() */
#define SEM_NEMPTY "nempty"
#define SEM_NSTORED "nstored"
int nitems; /* read-only by producer and consumer */
struct { /* data shared by producer and consumer */
 int buff[NBUFF];
 sem_t *mutex; 
 sem_t *nempty; 
 sem_t *nstored;
} shared;
void *produce(void *), *consume(void *);
int main(int argc, char **argv)
{
pthread_t tid_produce, tid_consume;
if (argc != 2) 
{
printf("usage: prodcons1 <#items>");
exit(1);
}
nitems = atoi(argv[1]);
/* 4create three semaphores */
shared.mutex = sem_open(SEM_MUTEX, O_CREAT | O_EXCL, 0644, 1);
shared.nempty = sem_open(SEM_NEMPTY, O_CREAT | O_EXCL, 0644, NBUFF);
shared.nstored = sem_open(SEM_NSTORED, O_CREAT | O_EXCL, 0644, 0);
/* 4create one producer thread and one consumer thread */
pthread_setconcurrency(2);
pthread_create(&tid_produce, NULL, produce, NULL);
pthread_create(&tid_consume, NULL, consume, NULL);
/* 4wait for the two threads */
pthread_join(tid_produce, NULL);
pthread_join(tid_consume, NULL);
/* 4remove the semaphores */
sem_unlink(SEM_MUTEX);
sem_unlink(SEM_NEMPTY);
sem_unlink(SEM_NSTORED);
exit(0);
}
/* end main */
/* include prodcons */
void *produce(void *arg)
{
int i;
for (i = 0; i < nitems; i++) {
sem_wait(shared.nempty); /* wait for at least 1 empty slot */
sem_wait(shared.mutex);
shared.buff[i % NBUFF] = i; /* store i into circular buffer */
sem_post(shared.mutex);
sem_post(shared.nstored); /* 1 more stored item */
}
return(NULL);
}
void *consume(void *arg)
{
int i;
for (i = 0; i < nitems; i++) {
sem_wait(shared.nstored); /* wait for at least 1 stored item */
sem_wait(shared.mutex);
if (shared.buff[i % NBUFF] == i)
printf("buff[%d] = %d\n", i, shared.buff[i % NBUFF]);
sem_post(shared.mutex);
sem_post(shared.nempty); /* 1 more empty slot */
}
return(NULL);
}

steps:
------
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ gcc lab12-procedure-consuming-using-seamphore.c -lpthread
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ ./a.out 5
=================================================================================================================================================
lab-12:-
------
lab12-procedure-consuming-using-seamphore:
---------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/types.h>
#define NBUFF 10
#define SEM_MUTEX "mutex" /* these are args to px_ipc_name() */
#define SEM_NEMPTY "nempty"
#define SEM_NSTORED "nstored"
int nitems; /* read-only by producer and consumer */
struct { /* data shared by producer and consumer */
 int buff[NBUFF];
 sem_t *mutex; 
 sem_t *nempty; 
 sem_t *nstored;
} shared;
void *produce(void *), *consume(void *);
int main(int argc, char **argv)
{
pthread_t tid_produce, tid_consume;
if (argc != 2) 
{
printf("usage: prodcons1 <#items>");
exit(1);
}
nitems = atoi(argv[1]);
/* 4create three semaphores */
shared.mutex = sem_open(SEM_MUTEX, O_CREAT | O_EXCL, 0644, 1);
shared.nempty = sem_open(SEM_NEMPTY, O_CREAT | O_EXCL, 0644, NBUFF);
shared.nstored = sem_open(SEM_NSTORED, O_CREAT | O_EXCL, 0644, 0);
/* 4create one producer thread and one consumer thread */
pthread_setconcurrency(2);
pthread_create(&tid_produce, NULL, produce, NULL);
pthread_create(&tid_consume, NULL, consume, NULL);
/* 4wait for the two threads */
pthread_join(tid_produce, NULL);
pthread_join(tid_consume, NULL);
/* 4remove the semaphores */
sem_unlink(SEM_MUTEX);
sem_unlink(SEM_NEMPTY);
sem_unlink(SEM_NSTORED);
exit(0);
}
/* end main */
/* include prodcons */
void *produce(void *arg)
{
int i;
for (i = 0; i < nitems; i++) {
sem_wait(shared.nempty); /* wait for at least 1 empty slot */
sem_wait(shared.mutex);
shared.buff[i % NBUFF] = i; /* store i into circular buffer */
sem_post(shared.mutex);
sem_post(shared.nstored); /* 1 more stored item */
}
return(NULL);
}
void *consume(void *arg)
{
int i;
for (i = 0; i < nitems; i++) {
sem_wait(shared.nstored); /* wait for at least 1 stored item */
sem_wait(shared.mutex);
if (shared.buff[i % NBUFF] == i)
printf("buff[%d] = %d\n", i, shared.buff[i % NBUFF]);
sem_post(shared.mutex);
sem_post(shared.nempty); /* 1 more empty slot */
}
return(NULL);
}
/* end prodcons */
/*

steps:
------
[vishnu@mannava pxsem]$ ./a.out 5


2)lab12-procedure-consuming-using-seamphore.c:
-----------------------------------------------
code:
-----
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/types.h>
#define NBUFF 10
#define SEM_MUTEX "mutex" /* these are args to px_ipc_name() */
#define SEM_NEMPTY "nempty"
#define SEM_NSTORED "nstored"
int nitems; /* read-only by producer and consumer */
struct { /* data shared by producer and consumer */
 int buff[NBUFF];
 sem_t *mutex; 
 sem_t *nempty; 
 sem_t *nstored;
} shared;
void *produce(void *), *consume(void *);
int main(int argc, char **argv)
{
pthread_t tid_produce, tid_consume;
if (argc != 2) 
{
printf("usage: prodcons1 <#items>");
exit(1);
}
nitems = atoi(argv[1]);
/* 4create three semaphores */
shared.mutex = sem_open(SEM_MUTEX, O_CREAT | O_EXCL, 0644, 1);
shared.nempty = sem_open(SEM_NEMPTY, O_CREAT | O_EXCL, 0644, NBUFF);
shared.nstored = sem_open(SEM_NSTORED, O_CREAT | O_EXCL, 0644, 0);
/* 4create one producer thread and one consumer thread */
pthread_setconcurrency(2);
pthread_create(&tid_produce, NULL, produce, NULL);
pthread_create(&tid_consume, NULL, consume, NULL);
/* 4wait for the two threads */
pthread_join(tid_produce, NULL);
pthread_join(tid_consume, NULL);
/* 4remove the semaphores */
sem_unlink(SEM_MUTEX);
sem_unlink(SEM_NEMPTY);
sem_unlink(SEM_NSTORED);
exit(0);
}
/* end main */
/* include prodcons */
void *produce(void *arg)
{
int i;
for (i = 0; i < nitems; i++) {
sem_wait(shared.nempty); /* wait for at least 1 empty slot */
sem_wait(shared.mutex);
shared.buff[i % NBUFF] = i; /* store i into circular buffer */
sem_post(shared.mutex);
sem_post(shared.nstored); /* 1 more stored item */
}
return(NULL);
}
void *consume(void *arg)
{
int i;
for (i = 0; i < nitems; i++) {
sem_wait(shared.nstored); /* wait for at least 1 stored item */
sem_wait(shared.mutex);
if (shared.buff[i % NBUFF] == i)
printf("buff[%d] = %d\n", i, shared.buff[i % NBUFF]);
sem_post(shared.mutex);
sem_post(shared.nempty); /* 1 more empty slot */
}
return(NULL);
}


stepsL
------
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ gcc lab12-procedure-consuming-using-seamphore.c -lpthread
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ ./a.out 5

2)lab12-procedure-consuming-using-cv.c
--------------------------------------
#include	<stdio.h>
#include	<unistd.h>
#include	<fcntl.h>
#include 	<pthread.h>
#include	<sys/types.h>

#define	MAXNITEMS 		1000000
#define	MAXNTHREADS		100

		/* globals shared by threads */
int		nitems;				/* read-only by producer and consumer */
int		buff[MAXNITEMS];
struct {
  pthread_mutex_t	mutex;
  int				nput;	/* next index to store */
  int				nval;	/* next value to store */
} put = { PTHREAD_MUTEX_INITIALIZER };

struct {
  pthread_mutex_t	mutex;
  pthread_cond_t	cond;
  int				nready;	/* number ready for consumer */
} nready = { PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER };
/* end globals */

void	*produce(void *), *consume(void *);

/* include main */
int
main(int argc, char **argv)
{
	int			i, nthreads, count[MAXNTHREADS];
	pthread_t	tid_produce[MAXNTHREADS], tid_consume;

	if (argc != 3)
	{
		printf("usage: prodcons6 <#items> <#threads>");
	}
	nitems = atoi(argv[1]);
	nthreads = atoi(argv[2]);

	pthread_setconcurrency(nthreads + 1);
		/* 4create all producers and one consumer */
	for (i = 0; i < nthreads; i++) {
		count[i] = 0;
		pthread_create(&tid_produce[i], NULL, produce, &count[i]);
	}
	pthread_create(&tid_consume, NULL, consume, NULL);

		/* wait for all producers and the consumer */
	for (i = 0; i < nthreads; i++) {
		pthread_join(tid_produce[i], NULL);
		printf("count[%d] = %d\n", i, count[i]);	
	}
	pthread_join(tid_consume, NULL);

	exit(0);
}
/* end main */

/* include prodcons */
void *
produce(void *arg)
{
	for ( ; ; ) {
		pthread_mutex_lock(&put.mutex);
		if (put.nput >= nitems) {
			pthread_mutex_unlock(&put.mutex);
			return(NULL);		/* array is full, we're done */
		}
		buff[put.nput] = put.nval;
		put.nput++;
		put.nval++;
		pthread_mutex_unlock(&put.mutex);

		pthread_mutex_lock(&nready.mutex);
		if (nready.nready == 0)
			pthread_cond_signal(&nready.cond);
		nready.nready++;
		pthread_mutex_unlock(&nready.mutex);

		*((int *) arg) += 1;
	}
}

void *
consume(void *arg)
{
	int		i;

	for (i = 0; i < nitems; i++) {
		pthread_mutex_lock(&nready.mutex);
		while (nready.nready == 0)
			pthread_cond_wait(&nready.cond, &nready.mutex);
		nready.nready--;
		pthread_mutex_unlock(&nready.mutex);

		if (buff[i] == i)
			printf("buff[%d] = %d\n", i, buff[i]);
	}
	return(NULL);
}
/* end prodcons */


steps:
------
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ gcc lab12-procedure-consuming-using-cv.c -lpthread
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ ./a.out 5 4

3) lab12-procedure-consuming-using-mutex.c
----------------------------------------------
code:
-----
#include	<stdio.h>
#include	<unistd.h>
#include	<fcntl.h>
#include 	<pthread.h>
#include	<sys/types.h>
#define	MAXNITEMS 		1000000
#define	MAXNTHREADS			100

int		nitems;			/* read-only by producer and consumer */
struct {
  pthread_mutex_t	mutex;
  int	buff[MAXNITEMS];
  int	nput;
  int	nval;
} shared ={PTHREAD_MUTEX_INITIALIZER};

void	*produce(void *), *consume(void *);

int
main(int argc, char **argv)
{
	shared.nput=0;
	shared.nval=0;
	int			i, nthreads, count[MAXNTHREADS];
	pthread_t	tid_produce[MAXNTHREADS], tid_consume;

	if (argc != 3)
		printf("usage: prodcons1 <#items> <#threads>");
	nitems = atoi(argv[1]);
	nthreads = atoi(argv[2]);
	pthread_setconcurrency(nthreads);
		/* 4start all the producer threads */
	for (i = 0; i < nthreads; i++) {
		count[i] = 0;
		pthread_create(&tid_produce[i], NULL, produce, &count[i]);
	}

		/* 4wait for all the producer threads */
	for (i = 0; i < nthreads; i++) {
		pthread_join(tid_produce[i], NULL);
		printf("count[%d] = %d\n", i, count[i]);	
	}

		/* 4start, then wait for the consumer thread */
	pthread_create(&tid_consume, NULL, consume, NULL);
	pthread_join(tid_consume, NULL);

	exit(0);
}
/* end main */

/* include producer */
void *
produce(void *arg)
{
pthread_t tid;
int i=*((int *) arg);
	for ( ; ; ) {
		pthread_mutex_lock(&shared.mutex);
		tid=pthread_self();
		printf("threadid=%u\n", (unsigned int) tid);
		if (shared.nput >= nitems) {
			pthread_mutex_unlock(&shared.mutex);
			return(NULL);		/* array is full, we're done */
		}
		shared.buff[shared.nput] = shared.nval;
		printf("buff[%d] = %d\n", shared.nput, shared.buff[shared.nput]);
		shared.nput++;
		shared.nval++;
		*((int *) arg) += 1;
		pthread_mutex_unlock(&shared.mutex);
		printf("shared.nput=%d, shared.nval=%d,count[%u] = %d\n",shared.nput,shared.nval, i, *((int *) arg));
		
	}
}

void *
consume(void *arg)
{
	int	i;
	for (i = 0; i <nitems; i++) {
		if (shared.buff[i] != i)
			printf("buff[%d] = %d\n", i, shared.buff[i]);
	}
	return(NULL);
}


steps:
-------
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ gcc lab12-procedure-consuming-using-mutex.c -lpthread
acer@DESKTOP-SF0LH7V:/mnt/c/Users/ACER/onedrive/desktop/xv6$ ./a.out 4 5






